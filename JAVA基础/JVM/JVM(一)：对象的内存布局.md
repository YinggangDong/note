# JVM(一)：对象的内存布局

> 在学习 **synchronized** 的过程中，发现其底层实现是和对象实例的对象头高度相关的，synchronized申请锁、上锁、释放锁都与对象头有关，因此有必要学习一下对象在内存中的布局，来加深对相关知识的了解。

## 对象内存构成

当我们通过 new 来创建一个类的实例对象时，JVM会在堆中给这个对象分配一个内存地址，那么有几个问题值得探究一下：

- 这个实例对象在内存中都有些什么内容?
- 每当 new 出一个对象时，它所占用的内存到底有多大？
- 对象中的属性是如何在内存中分配的？

在JVM中，对象实例被保存在堆中，由以下三部分构成：

- **对象头（object header）**：包含包括两部分信息，**对象自身的运行时数据**和**类型指针**
- **实例数据（Instance Data）**：存放类的数据信息
- **对齐填充（Padding）**：无实际意义，仅为了将对象填充为8字节的倍数

内存布局示例图如下：

![image-20210223191719860](图片/image-20210223191719860.png)

如哈希码、GC分带年龄，锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度为