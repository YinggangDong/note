# 30讲：答疑文章（二）：用动态的观点看加锁

**加锁规则：包含了两个“原则”、两个“优化”和一个“bug”**

- 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
- 原则2：查找过程中访问到的对象才会加锁。
- 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
- 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
- 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

本讲讨论基于下面的表t进行

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

## 不等号条件里的等值查询

```mysql
begin;
select * from t where id>9 and id<12 order by id desc for update;
```

利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。也就是说，id=15这一行，并没有被加上行锁。为什么呢？

我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，即索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁 (10, 15)。

1. 首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id<12的值”。
2. 这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。
3. 然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock (0,5]。

也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。

## 等值查询的过程

下面这个语句的加锁范围是什么？

```mysql
begin;
select id from t where c in(5,20,10) lock in share mode;
```

1. 在查找c=5的时候，先锁住了（0,5]这个next-key lock。然后由于c不是唯一索引，为了确认是否还有别的记录c=5，所以要向右遍历，找到c=10才能够确认没有了，这个过程满足优化2，因此会加间隙锁（5,10）。
2. 在执行c=10时，加锁范围逻辑同上，会锁（5,10]和（10,15）。
3. 在执行c=20时，加锁范围逻辑同上，会锁（15,20]和（20,25）。

加锁过程实际是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。

值得强调的是：这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。

