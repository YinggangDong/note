# 509. 斐波那契数

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

思路详解：https://labuladong.gitbook.io/algo/bi-du-wen-zhang/dong-tai-gui-hua-xiang-jie-jin-jie

从递归-》递归+备忘录

## 1 递归

![img](https://gblobscdn.gitbook.com/assets%2F-MWvhB2heCSJoT6IpxDY%2Fsync%2F70af23686865b425f7b88f172ac696878985f4c6.jpg?alt=media)

```java
public int fib(int n) {
        //递归
        if(n==0){
            return 0;
        }else if(n<=2){
            return 1;
        }else{
            return fib(n-1)+fib(n-2);
        }
}
```



## 2 递归+备忘录

通过备忘录记录参数为n的时候的递归结果，减少递归次数。

![img](https://gblobscdn.gitbook.com/assets%2F-MWvhB2heCSJoT6IpxDY%2Fsync%2Fe6547795e536cbd16b7f5f23da637032cc88e87e.jpg?alt=media)

```java
class Solution {
    public int fib(int n) {
        //递归+备忘录
        if(n<2){
            return n;
        }
        int[] memo = new int[n+1];
        memo[1] = 1;
        return helper(n,memo);

    }

    int helper(int n,int[] memo){
        if(n==0 || memo[n]!=0){
            return memo[n];
        }    
        memo[n] = helper(n-1,memo)+helper(n-2,memo);
        return memo[n];
    }
}
```

每个数的递归只进行一次，不会多次进行了。

## 3 dp 数组

```java
class Solution {
    //dp数组
    public int fib(int n) {
        if(n<2){
            return n;
        }
        int dp[] = new int[n+1];
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

## 4 dp 优化

因为 dp[n] 只依赖于 dp[n-1] 和 dp[n-2] , 所以可以不记录所有的 n 对应的结果，只需要记录前面两个数，所以可以不使用数组，只使用两个 int 值进行记录。

```java
class Solution {
    public int fib(int n) {
        if(n<2){
            return n;
        }
        int p=0;
        int q=0;
        int res = 1;
        for(int i=2;i<=n;i++){
            p = q;
            q = res;
            res = p+q;
        }
        return res;
    }
}
```

