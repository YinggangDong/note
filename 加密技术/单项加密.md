## 1.Base64

#### 简介

Base64编码是网络上常见的用于传输8bit字节数据的一种编码方式之一，所以可以依据概括：它是一种编码方式，记住它**不是加密**的方式，它没有秘钥的概念，任何人拿到数据都能解析出来。它只是**一种编码方式**！！

 

#### 使用场景

我们在参数传输的过程中肯定遇到过这样一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是**基于64个可打印的字符来表示二进制的数据**的一种方法。

电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。

#### 原理

Base64编码将一个8位字节序列拆散为6位的片段，而且这每个6位的片段都会被分配一个字符，那这个是个什么字符呢？其实它是base64字母表中的64个字符之一，所以顾名思义base64了。而这64个字符可是有讲究的，是选择了最常用而且兼容性最好的64个字符。所以可以算出base64编码后的字符串大约比编码前大了33%，因为用8位来表示6位。下面的详细的例子，大家来感受下。

Base64还有几个规则如下：

①.3字符变为4字符。

②每76个字符增加一个换行符。

③.结束符也要编码。

大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反，

Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。

中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。

 

加入编码前的数据是“Ow!”，那编码之后是4个字符的base64编码值“T3ch”。下面是具体的转换过程。

·         1， 字符串"Ow!"被拆分成3个8位的字节(ASCII码)(0x4F、0x77、0x21)。看下图：

![1604311823569](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604311823569.png)

·        
2， 这3字节构成了一个24位的二进制 01001111 ，01110111，00100001。看下图：

![1604311989051](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604311989051.png)

·        
3， 这些为被划分为一些6位的序列010011、110111、011100、1000001。看下图：

![1604312022675](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604312022675.png)

·        
4， 每6位值都表示了从0～63数值，在base64字母表中的都有对应的字符。所以查表转换得出是4字符的字符串“T3ch”。如下图所示转换表。

![1604312048976](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604312048976.png)

## 2.MD5（消息摘要[算法](http://www.tomorrow.wiki/tag/%e7%ae%97%e6%b3%95/)）Message Digest algorithm 5

#### 简介

MD5算法为计算机安全领域广泛使用的一种**散列**函数，用以提供消息的完整性保护。用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一。

**MD5****算法具有以下特点：
 1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。
 2、容易计算：从原数据计算出MD5值很容易。
 3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
 4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
 5、强抗碰撞：**想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。

**根据以上特点衍生出来可以供我们使用的特性：**
 **方便存储：**MD5加密出来都是32位的字符串，能够给定固定大小的空间存储，传输，验证
 **文件加密：**MD5算法运用在文件加密上很有优势，应为只需要32位字符串就能对一个巨大的文件进行验证完整性
 **不** **可** **逆：**MD5加密出来只会截取末尾32位，具有良好的安全性，如果是对于参数加密很难伪造MD5
 **加密损耗低：**MD5算法加密对于性能的消耗微乎其微。

#### 使用场景

MD5应用场景较多，例如用户密码、微信支付验签、文件校验等等。

#### 原理

MD5算法的原理可简要的叙述为：MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。

总体流程如下图所示，每次的运算都由前一轮的128位结果值和当前的512bit值进行运算。

![1604312439781](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604312439781.png)

### 破解

md5是不可逆的，也就是没有对应的算法，从生产的md5值逆向得到原始数据。但是如果使用暴力破解，那就另说了。
如果要求不高，比如保存个密码啥的，问题不大。为了防止破解，加个 Salt 最好。



## 3、SHA（安全散列[算法](http://www.tomorrow.wiki/tag/%e7%ae%97%e6%b3%95/)）Secure Hash Algorithm

#### 简介

SHA是一系列的加密算法，有SHA-1、SHA-2、SHA-3三大类，而SHA-1已经被破解，SHA-3应用较少，目前应用广泛相对安全的是SHA-2算法，这也是本篇文章重点讲述的算法SHA-256。

该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段密文，也可以简单的理解为取一串输入码，并把它们转化为长度较短、**位数固定**的输出序列即散列值的过程。SHA算法的底层原理和MD5很相似，只是在摘要分段和处理细节上有少许差别。

 

#### 使用场景



#### 原理

为了更好的理解SHA256的原理，这里首先将算法中可以单独抽出的模块，包括`常量的初始化`、`信息预处理`、`使用到的逻辑运算`分别进行介绍，甩开这些理解上的障碍后，一起来探索SHA256算法的主体部分，即消息摘要是如何计算的。

我们先来回顾一下MD5算法的核心过程，简而言之，MD5把128bit的信息摘要分成A，B，C，D四段（Words），每段32bit，在循环过程中交替运算A，B，C，D，最终组成128bit的摘要结果。

![1604315346681](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604315346681.png)

再看一下SHA-1算法，核心过程大同小异，主要的不同点是把160bit的信息摘要分成了A，B，C，D，E五段。

![1604315390156](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604315390156.png)

再看一下SHA-2系列算法，核心过程更复杂一些，把信息摘要分成了A，B，C，D，E，F，G，H八段。

![1604315410108](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604315410108.png)

其中SHA-256的每一段摘要长度是32bit，SHA-512的每一段摘要长度是64bit。SHA-224和SHA-384则是在前两者生成结果的基础上做出裁剪。

几点补充：

SHA家族的最新成员SHA-3已经于2015年问世。关于SHA-3的细节，有兴趣的小伙伴们可以查询资料进一步学习。



## 4.HMAC（散列消息鉴别码[算法](http://www.tomorrow.wiki/tag/%e7%ae%97%e6%b3%95/)）Hash Message Authentication Code

### 简介

**HMAC算法是一种基于密钥的报文完整性的验证方法** ，其安全性是建立在Hash加密算法基础上的。它要求通信双方共享密钥、约定算法、对报文进行Hash运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。 **HMAC算法可以用来作加密、数字签名、报文验证等** 。（实际情况中用HMAC做加密也是为的不可逆加密，不像用DES/AES这种可逆加密；感觉HMAC和随机盐Hash算法非常像）

一句话总结：HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。

使用SHA-1、SHA-224、SHA-256、SHA-384、SHA-512所构造的HMAC，分别称为HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-384、HMAC-SHA-512。

### 使用场景

HMAC算法可以用来作加密、数字签名、报文验证等

### 原理

HMAC算法是一种执行“校验和”的算法，它通过对数据进行“校验”来检查数据是否被更改了。在发送数据以前，HMAC算法对数据块和双方约定的公钥进行“散列操作”，以生成称为“摘要”的东西，附加在待发送的数据块中。当数据和摘要到达其目的地时，就使用HMAC算法来生成另一个校验和，如果两个数字相匹配，那么数据未被做任何篡改。否则，就意味着数据在传输或存储过程中被某些居心叵测的人作了手脚。

HMAC算法的定义用公式表示如下：

HMAC（K，M）=H（（K’⊕opad）∣H（（K’⊕ipad）∣M））

HMAC算法的加密步骤：

(1) 在密钥K后面添加0 或者 对密钥K用H进行处理 来创建一个字长为B的字符串。(例如，如果K的字长是20字节，B＝64字节，则K后会加入44个零字节0x00；如果K的字长是120字节，B＝64字节，则会用H作用于K后产生64字节的字符串)

(2) 将上一步生成的B字长的字符串与ipad做异或运算。

(3) 将数据流text填充至第二步的结果字符串中。

(4) 用H作用于第三步生成的数据流。

(5) 将第一步生成的B字长字符串与opad做异或运算。

(6) 再将第四步的结果填充进第五步的结果中。

(7) 用H作用于第六步生成的数据流，输出最终结果 。



