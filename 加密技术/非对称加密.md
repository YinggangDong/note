## 非对称加密

### 1.DH(密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm))

DH让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容.

原理图：![1604210637875](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604210637875.png)

再举个”栗子“：
A和B想要在一个不安全的信道共享一个密钥，该密钥可被用来进行后续的其他的操作，并且仅被A和B所知，第三方无法得知。
一个简单的方法就是，现在全世界都是知道一个值 P=100。Alice生成随机值5，然后乘上P，接着发送Pa = 500给B；通样B生成随机值6，然后乘上P，接着发送Pb = 600给A。
这样，A 有 100，5 ，600，B有100，6,500。

A计算: 随机值5（自己私钥） * 600（对端的公钥） = 3000 等式1
B计算 : 随机值6（自己私钥） * 500（对端的公钥） = 3000 等式2

​    这样 A就和B共享了一个值3000，还有谁知道3000这个值呢？我们知道A明文的将500发送到不安全信道，B明文的将600发送到不安全信道，这也就意味着第三方仅仅知道500 和 600，想要计算获得共享密钥，第三方要么获取到A的随机值然后拿它乘上600，要么获取到Bob的随机值然后拿它乘上500，这样才能获取到A和B的共享密钥。

​    如何获取到A的随机值呢？

​    第三方知道，A发送的500是由P乘上A的随机值得到的，所以问题变成了求方程 x*100 = 500的解。一眼就能看出来，A的随机值是5。

所以怎么要让中间人难以从Pa或者Pb中分解得到A或B的随机数，而A和B又能轻松的通过P和随机数计算得到Pa和Pb，就成了设计这个算法的关键。从上面的例子可以看出，简单的乘法运算是不行的。
    一般来说上述所说的全世界都知道的值P称之为公钥，为A和B的随机数称之为私钥。



对称秘钥生成示意图：

![1604211171499](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604211171499.png)

举个“栗子”：

1.A与B协定使用p=23以及g=5.
2.A选择一个秘密整数a=6, 计算A = g^a mod p并发送给B。
    A = 5^6 mod 23 = 8.
3.B选择一个秘密整数b=15, 计算B = g^b mod p并发送给A。
    B = 5^15 mod 23 = 19.
4.A计算s = B a mod p
   19^6 mod 23 = 2.
5.B计算s = A b mod p
   8^15 mod 23 = 2. 



### 2.RSA

RSA 是非对称算法，加解密使用不同的密钥。

**两个密钥都可以用于加密**，解密时需要使用另一个密钥。但是，通常用公钥加密私钥解密，因为公钥是近乎完全公开的，对于私钥加密的数据，有太多的人可以解密了。理论上 A 和 B 之间要通过 RSA 实现保密通信，需要 A 和 B 各自生成一组密钥，同时保管好自己的私钥；用对方的公钥加密要发送的消息，用自己的私钥解密对方发送过来的消息。

在签名的场景下，用私钥签名，公钥验签。

RSA 比 DES 等对称算法慢得多。一般在实际数据传输时，用 RSA 来加密比较短的对称密码，双方交换密码后再使用 DES 等对称算法传输数据。

![1604231077336](C:\Users\lixiang2\AppData\Roaming\Typora\typora-user-images\1604231077336.png)



## RSA加密（防泄漏）

1：A（如：客户端）在本地生成私钥和公钥
2：A将公钥发给B（如：服务器）
3：B使用公钥加密后，将密文返回给A
4：A使用本地的私钥解密

**防泄漏的原理：**
由于私钥存在**本地**，**传输内容**是公钥和密文，即使中途被黑客**截获**，也无法解密。

## RSA签名（防篡改）

1：A生成私钥和公钥，公钥公开，私钥签名（加密）
2：A将**明文、签名**发给B
2：B使用公开的公钥验签（解密），验签结果和明文一致，则证明内容没被黑客篡改过。

**防篡改的原理：**
由于公钥是**公开的**， 并且只能用来开对应私钥的锁，因此，即使黑客**篡改了明文**却**没有私钥**对明文进行**重新签名**，所以B通过验签比对即可发现明文已经被篡改。
为了减少计算开销，签名只要加密内容的 hash即可，B将收到的明文内容hash后 与用公钥对签名解密后的内容 进行比对 即可验证是否被篡改。

**为什么要公开：**
如果公钥不是公开的，而是和明文、签名一起发出，那么黑客即可通过自己的私钥进行篡改公钥、明文以及签名。
所以A和B在第一次连接时仅做公钥交换，后续再对交互内容进行签名加密就可以保证安全了。

## 同时防泄漏和防篡改

结合二者，A和B分别生成密钥对(公钥a1,私钥a2)和密钥对(公钥b1,私钥b2)，A发出公钥a1给B加密或验签，B同样发出公钥b1给A加密或验签，即可保证更大限度的安全。简单来说，这便是一个**交换公钥的过程**。





对称加密和非对称加密对比：

- 对称加密算法

> 加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。

- 非对称加密算法

> 加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal。









